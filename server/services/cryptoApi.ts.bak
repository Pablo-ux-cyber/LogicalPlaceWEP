import axios from 'axios';

interface CryptoResponse {
  time: number;
  close: number;
  high: number;
  low: number;
  open: number;
  volumefrom: number;
  volumeto: number;
}

export interface CryptoCurrency {
  id: string;        // Symbol (BTC, ETH, etc.)
  name: string;      // Full name (Bitcoin, Ethereum, etc.)
  marketCap: number; // Market capitalization
  price: number;     // Current price
  imageUrl: string;  // URL to the crypto logo
  rank: number;      // Rank by market cap
}

export type CryptoSymbol = string; // Now we'll support any symbol

// Список криптовалют для проверки, предоставленный пользователем
export const CRYPTO_LIST = [
      'BTC', 'ETH', 'XRP', 'BNB', 'SOL', 'DOGE', 'ADA', 'TRX',
      'SUI', 'LINK', 'AVAX', 'XLM', 'LEO', 'TON', 'SHIB', 'HBAR',
      'BCH', 'LTC', 'DOT', 'HYPE',
      'BGB', 'PI', 'XMR',
      'CBBTC', 'PEPE', 'UNI', 'APT', 'OKB', 'NEAR', 'TAO', 'ONDO', 'TRUMP', 'GT', 'ICP',
      'ETC', 'AAVE', 'KAS', 'CRO', 'MNT', 'VET', 'RENDER',
      'POL', 'ATOM', 'ENA',
      'FET', 'ALGO', 'FTN', 'FIL', 'TIA',
      'ARB',
      'WLD', 'BONK',
      'STX', 'JUP', 'KCS', 'OP', 'MKR',
      'NEXO', 'QNT', 'FARTCOIN', 'IMX', 'IP',
      'FLR', 'SEI', 'EOS', 'INJ',
      'GRT',
      'CRV',
      'RAY'
    ];
// Function to fetch top cryptocurrencies by market cap
export async function fetchTopCryptos(limit: number = 100): Promise<CryptoCurrency[]> {
  try {
    const apiKey = process.env.CRYPTOCOMPARE_API_KEY;
    
    // Отфильтруем список, чтобы ограничить максимальным количеством монет, если указан лимит
    const limitedList = CRYPTO_LIST.slice(0, limit);
    const cryptoList = limitedList.join(',');
    
    // URL и параметры для запроса цен нескольких монет одновременно
    const url = 'https://min-api.cryptocompare.com/data/pricemultifull';
    const params = {
      fsyms: cryptoList, // Используем наш список
      tsyms: 'USD',
      api_key: apiKey
    };
    
    // Полные названия для монет
    const fullNames: {[key: string]: string} = {
      'BTC': 'Bitcoin',
      'ETH': 'Ethereum',
      'BNB': 'Binance Coin',
      'SOL': 'Solana',
      'XRP': 'XRP',
      'ADA': 'Cardano',
      'DOGE': 'Dogecoin',
      'AVAX': 'Avalanche',
      'DOT': 'Polkadot',
      'TRX': 'TRON',
      'LINK': 'Chainlink',
      'XLM': 'Stellar',
      'LEO': 'LEO Token',
      'TON': 'Toncoin',
      'SHIB': 'Shiba Inu',
      'HBAR': 'Hedera',
      'BCH': 'Bitcoin Cash',
      'LTC': 'Litecoin',
      'HYPE': 'Hyperliquid',
      'BGB': 'Bitget Token',
      'PI': 'Pi Network',
      'XMR': 'Monero',
      'CBBTC': 'Cave Bitcoin',
      'PEPE': 'Pepe',
      'UNI': 'Uniswap',
      'APT': 'Aptos',
      'OKB': 'OKB',
      'NEAR': 'NEAR Protocol',
      'TAO': 'Bittensor',
      'ONDO': 'Ondo',
      'TRUMP': 'Trump',
      'GT': 'GateToken',
      'ICP': 'Internet Computer',
      'ETC': 'Ethereum Classic',
      'AAVE': 'Aave',
      'KAS': 'Kaspa',
      'CRO': 'Cronos',
      'MNT': 'Mantle',
      'VET': 'VeChain',
      'RENDER': 'Render',
      'POL': 'Polygon zkEVM',
      'ATOM': 'Cosmos Hub',
      'ENA': 'Ethena',
      'FET': 'Fetch.ai',
      'ALGO': 'Algorand',
      'FTN': 'Fountain',
      'FIL': 'Filecoin',
      'TIA': 'Celestia',
      'ARB': 'Arbitrum',
      'WLD': 'Worldcoin',
      'BONK': 'Bonk',
      'STX': 'Stacks',
      'JUP': 'Jupiter',
      'KCS': 'KuCoin Token',
      'OP': 'Optimism',
      'MKR': 'Maker',
      'NEXO': 'Nexo',
      'QNT': 'Quant',
      'FARTCOIN': 'Fartcoin',
      'IMX': 'Immutable X',
      'IP': 'IP',
      'FLR': 'Flare',
      'SEI': 'Sei',
      'EOS': 'EOS',
      'INJ': 'Injective',
      'GRT': 'The Graph',
      'CRV': 'Curve DAO',
      'RAY': 'Raydium'
    };
    
    // Запрашиваем данные для всех монет одним запросом
    console.log(`Requesting data for ${limitedList.length} cryptocurrencies...`);
    
    try {
      const response = await axios.get(url, { params });
      
      let result: CryptoCurrency[] = [];
      
      if (response.data && response.data.RAW) {
        // Преобразуем данные в наш формат
        for (let i = 0; i < limitedList.length; i++) {
          const symbol = limitedList[i];
          
          if (response.data.RAW[symbol] && response.data.RAW[symbol].USD) {
            const data = response.data.RAW[symbol].USD;
            
            result.push({
              id: symbol,
              name: fullNames[symbol] || symbol, // Используем ранее определенное имя или сам символ
              marketCap: data.MKTCAP || 0,
              price: data.PRICE || 0,
              imageUrl: data.IMAGEURL ? `https://www.cryptocompare.com${data.IMAGEURL}` : '',
              rank: i + 1 // Ранг по порядку в нашем списке
            });
          } else {
            // Если данных нет, добавляем монету без данных о цене
            result.push({
              id: symbol,
              name: fullNames[symbol] || symbol,
              marketCap: 0,
              price: 0,
              imageUrl: '',
              rank: i + 1
            });
          }
        }
      } else {
        console.log('API returned invalid data format, creating list with empty price data');
        
        // Если API не вернул данные, создаем список без данных о ценах
        result = limitedList.map((symbol, index) => ({
          id: symbol,
          name: fullNames[symbol] || symbol,
          marketCap: 0,
          price: 0,
          imageUrl: '',
          rank: index + 1
        }));
      }
      
      console.log(`Fetched ${result.length} cryptocurrencies from the specified list`);
      return result;
    } catch (error) {
      console.error('Error in fetchTopCryptos:', error);
      
      // В случае ошибки возвращаем список монет без данных о ценах
      return limitedList.map((symbol, index) => ({
        id: symbol,
        name: fullNames[symbol] || symbol,
        marketCap: 0,
        price: 0,
        imageUrl: '',
        rank: index + 1
      }));
    }
  } catch (error) {
    console.error('Error in fetchTopCryptos:', error);
    return []; // Return empty array on error
  }
}
    
    // Сначала пробуем получить данные из API
    const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull';
    
    const params = {
      limit: limit + 50, // Request more to compensate for filtering
      tsym: 'USD',
      api_key: apiKey
    };
    
    try {
      // Запрос к API для получения топ-криптовалют
      const response = await axios.get(url, { params });
      
      if (response.data && response.data.Data && Array.isArray(response.data.Data)) {
        // Transform the data to our format
        topCryptos = response.data.Data
          .filter((item: any) => item.CoinInfo && item.RAW?.USD) // Ensure data is valid
          .map((item: any, index: number) => {
            const coinInfo = item.CoinInfo || {};
            const raw = item.RAW?.USD || {};
            
            return {
              id: coinInfo.Name || '',
              name: coinInfo.FullName || '',
              marketCap: raw.MKTCAP || 0,
              price: raw.PRICE || 0,
              imageUrl: coinInfo.ImageUrl ? `https://www.cryptocompare.com${coinInfo.ImageUrl}` : '',
              rank: index + improvedMajorCryptos.length + 1 // Start after major coins
            };
          })
          .filter((crypto: CryptoCurrency) => {
            // Remove empty entries
            if (!crypto.id || !crypto.name) return false;
            
            // Already have this in major coins
            if (majorCoins.includes(crypto.id)) return false;
            
            // Filter out stablecoins
            const stablecoins = ['USDT', 'USDC', 'DAI', 'BUSD', 'TUSD', 'GUSD', 'USDD', 'USDP', 'FRAX', 'LUSD'];
            if (stablecoins.includes(crypto.id)) return false;
            
            // Filter out wrapped tokens
            const wrappedTokens = ['WBTC', 'WETH', 'WBNB', 'WAVAX', 'WMATIC', 'WFTM', 'WSOL', 'WTRX', 'WONE', 'WRUNE'];
            if (wrappedTokens.includes(crypto.id)) return false;
            
            // Filter out by name patterns
            if (
              crypto.name.toLowerCase().includes('wrapped') || 
              crypto.name.toLowerCase().includes('usd') || 
              crypto.id.startsWith('W') && crypto.name.includes('(') || 
              crypto.id.includes('USD')
            ) return false;
            
            return true;
          });
          
        console.log(`Successfully got ${topCryptos.length} additional cryptocurrencies from the API`);
      } else {
        console.log('API returned invalid data format, using predefined list of additional cryptocurrencies');
        
        // Если API вернул некорректные данные, используем предопределенный список
        topCryptos = additionalCoins
          .filter(coin => !majorCoins.includes(coin.id))
          .map((coin, index) => {
            // Создаем объект криптовалюты с примерными данными
            return {
              id: coin.id,
              name: coin.name,
              marketCap: 0, // Точное значение будет получено при запросе конкретной монеты
              price: 0,     // Точное значение будет получено при запросе конкретной монеты
              imageUrl: '', // Иконка будет получена при необходимости
              rank: index + improvedMajorCryptos.length + 1
            };
          });
          
        console.log(`Using ${topCryptos.length} predefined additional cryptocurrencies`);
      }
    } catch(error) {
      console.log('Failed to get additional cryptocurrencies from API, using predefined list');
      
      // Если произошла ошибка при запросе к API, используем предопределенный список
      // и делаем отдельные запросы для получения реальных данных о ценах и капитализации
      const additionalCryptoPromises = additionalCoins
        .filter(coin => !majorCoins.includes(coin.id))
        .map(async (coin, index) => {
          try {
            // Делаем запрос для получения реальных данных по каждой монете
            const singleCoinUrl = 'https://min-api.cryptocompare.com/data/pricemultifull';
            const singleCoinParams = {
              fsyms: coin.id,
              tsyms: 'USD',
              api_key: apiKey
            };
            
            const response = await axios.get(singleCoinUrl, { params: singleCoinParams });
            
            // Проверяем валидность ответа
            if (response.data && response.data.RAW && response.data.RAW[coin.id] && response.data.RAW[coin.id].USD) {
              const coinData = response.data.RAW[coin.id].USD;
              
              return {
                id: coin.id,
                name: coin.name,
                marketCap: coinData.MKTCAP || 0,
                price: coinData.PRICE || 0,
                imageUrl: coinData.IMAGEURL ? `https://www.cryptocompare.com${coinData.IMAGEURL}` : '',
                rank: index + improvedMajorCryptos.length + 1
              };
            } else {
              // Если данные не получены, создаем запись с минимальными данными
              return {
                id: coin.id,
                name: coin.name,
                marketCap: 0,
                price: 0,
                imageUrl: '',
                rank: index + improvedMajorCryptos.length + 1
              };
            }
          } catch (err) {
            // В случае ошибки, создаем запись с минимальными данными
            console.log(`Error fetching data for ${coin.id}: ${err}`);
            return {
              id: coin.id,
              name: coin.name,
              marketCap: 0,
              price: 0,
              imageUrl: '',
              rank: index + improvedMajorCryptos.length + 1
            };
          }
        });
      
      // Ждем завершения всех запросов
      topCryptos = await Promise.all(additionalCryptoPromises);
        
      console.log(`Using ${topCryptos.length} predefined additional cryptocurrencies`);
    }
    
    // Combine major coins with top coins and limit to requested amount
    const allCryptos = [...improvedMajorCryptos, ...topCryptos].slice(0, limit);
    
    console.log(`Fetched ${allCryptos.length} cryptocurrencies (including ${improvedMajorCryptos.length} major coins)`);
    return allCryptos;
  } catch (error) {
    console.error('Error fetching top cryptocurrencies:', error);
    throw new Error('Failed to fetch top cryptocurrencies');
  }
}

export async function fetchCryptoPriceData(symbol: CryptoSymbol, timeframe: string) {
  // Map timeframe to API parameters
  const limit = 5000; // Try to get more historical data (max API allows)
  
  // Map frontend timeframes to API timeframes
  let apiTimeframe = 'hour';
  let aggregate = 1;
  
  switch (timeframe) {
    case '1h':
      apiTimeframe = 'hour';
      break;
    case '4h':
      apiTimeframe = 'hour';
      aggregate = 4;
      break;
    case '1d':
      apiTimeframe = 'day';
      break;
    case '1w':
      apiTimeframe = 'day';  // We'll get daily data and convert to weekly
      aggregate = 1;         // No aggregation, we'll do it manually
      break;
    default:
      apiTimeframe = 'hour';
  }
  
  // Use the base API URL
  const baseUrl = 'https://min-api.cryptocompare.com/data/v2/';
  
  // For weekly timeframe, get maximum available data
  // Limit to 2000 to avoid API errors
  const requestLimit = 2000;
  
  // Complete API URL
  const url = `${baseUrl}histo${apiTimeframe}`;
  
  // Using the API key from environment
  const apiKey = process.env.CRYPTOCOMPARE_API_KEY;
  
  const params = {
    fsym: symbol,          // From Symbol (cryptocurrency)
    tsym: 'USD',           // To Symbol (US Dollar)
    limit: requestLimit,   // Use our adjusted limit value
    aggregate: aggregate,  // Aggregate data points
    api_key: apiKey        // API key for authentication
  };
  
  try {
    const response = await axios.get(url, { params });
    
    // Check if we have valid data
    if (!response.data || !response.data.Data || !response.data.Data.Data) {
      console.error('Invalid response structure from CryptoCompare:', JSON.stringify(response.data, null, 2));
      throw new Error('Invalid data format from CryptoCompare API');
    }
    
    const rawData = response.data.Data.Data;
    console.log(`Received ${rawData.length} data points for ${timeframe} timeframe`);
    
    // Return all available data points
    const limitedData = rawData;
    
    // Transform the data to the format needed by the chart
    const candles = limitedData.map((item: CryptoResponse) => ({
      time: item.time as number,
      open: item.open,
      high: item.high,
      low: item.low,
      close: item.close
    }));
    
    // Create volume data
    const volumes = limitedData.map((item: CryptoResponse) => ({
      time: item.time as number,
      value: item.volumefrom,
      color: item.close >= item.open ? '#26A69A' : '#EF5350'
    }));
    
    return { candles, volumes };
  } catch (error) {
    console.error('Error fetching data from CryptoCompare:', error);
    // If weekly timeframe fails, use daily data with weekly aggregation as fallback
    if (timeframe === '1w') {
      console.log('Trying fallback to daily data for weekly timeframe');
      // Create a modified copy of the current function params for daily data
      try {
        const dailyUrl = `${baseUrl}histoday`;
        const dailyParams = {
          ...params,
          aggregate: 1,  // Get raw daily data
          limit: 2000    // Get maximum data for weekly aggregation
        };
        
        const dailyResponse = await axios.get(dailyUrl, { params: dailyParams });
        if (!dailyResponse.data || !dailyResponse.data.Data || !dailyResponse.data.Data.Data) {
          throw new Error('Invalid daily data format from fallback API call');
        }
        
        const rawDailyData = dailyResponse.data.Data.Data;
        
        // Формируем недельные свечи по тому же принципу, как TradingView
        const weeklyCandles: CryptoResponse[] = [];
        
        // TradingView обычно начинает неделю с понедельника
        for (let i = 0; i < rawDailyData.length; i += 1) {
          const date = new Date(rawDailyData[i].time * 1000);
          const dayOfWeek = date.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
          
          // Если понедельник (или первая свеча в данных), начинаем новую неделю
          if (dayOfWeek === 1 || i === 0) {
            // Найдем следующий понедельник или конец данных
            let endIndex = i + 1;
            while (endIndex < rawDailyData.length) {
              const nextDate = new Date(rawDailyData[endIndex].time * 1000);
              if (nextDate.getDay() === 1) break; // Нашли следующий понедельник
              endIndex++;
            }
            
            const weekData = rawDailyData.slice(i, endIndex);
            
            if (weekData.length > 0) {
              // Формируем недельную свечу в точности как TradingView:
              // Open = первое значение периода
              // High = максимум за период
              // Low = минимум за период
              // Close = последнее значение периода 
              const weekCandle: CryptoResponse = {
                time: weekData[0].time,
                open: weekData[0].open,
                high: Math.max(...weekData.map((c: CryptoResponse) => c.high)),
                low: Math.min(...weekData.map((c: CryptoResponse) => c.low)),
                close: weekData[weekData.length - 1].close,
                volumefrom: weekData.reduce((sum: number, c: CryptoResponse) => sum + c.volumefrom, 0),
                volumeto: weekData.reduce((sum: number, c: CryptoResponse) => sum + c.volumeto, 0)
              };
              weeklyCandles.push(weekCandle);
            }
          }
        }
        
        // Transform the weekly candles to chart format
        const candles = weeklyCandles.map(item => ({
          time: item.time as number,
          open: item.open,
          high: item.high,
          low: item.low,
          close: item.close
        }));
        
        // Create volume data
        const volumes = weeklyCandles.map(item => ({
          time: item.time as number,
          value: item.volumefrom,
          color: item.close >= item.open ? '#26A69A' : '#EF5350'
        }));
        
        console.log(`Generated ${candles.length} weekly candles from daily data (fallback method)`);
        return { candles, volumes };
      } catch (fallbackError) {
        console.error('Error in fallback weekly data generation:', fallbackError);
        throw new Error('Failed to fetch weekly cryptocurrency data (even with fallback)');
      }
    } else {
      throw new Error('Failed to fetch cryptocurrency data');
    }
  }
}